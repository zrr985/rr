# 视觉检测系统数据流向分析

## 1. 系统整体数据流

### 1.1 核心数据流向
```
摄像头硬件 → 图像采集 → 任务调度 → 模型推理 → 结果处理 → UDP通信 → 外部系统
    ↑                                                              ↓
    └────────────────── 控制命令反馈 ──────────────────────────────┘
```

### 1.2 主要组件
- **摄像头模块**: 红外/RGB摄像头自动识别和管理
- **任务管理模块**: 多线程任务调度和队列管理
- **RKNN模型池**: 并发推理和NPU核心管理
- **UDP通信模块**: 双向通信协议和数据帧处理

## 2. 内部数据流详解

### 2.1 摄像头数据流
```
系统扫描 → 硬件识别 → 设备打开 → 图像采集 → 队列缓存
```

**关键代码：**
```python
# video_number.py - 自动识别摄像头
def get_camera_numbers():
    # 扫描 /sys/class/video4linux/
    # 返回红外和RGB摄像头编号列表

# CameraManager类 - 摄像头管理
class CameraManager:
    def get_infrared_camera(self):  # 获取红外摄像头
    def get_rgb_camera(self):       # 获取RGB摄像头

# camera_capture函数 - 图像采集
def camera_capture(cam, frame_queue, stop_event):
    while not stop_event.is_set():
        ret, frame = cam.read()     # 读取图像帧
        frame_queue.put(frame)      # 放入队列
```

### 2.2 任务调度数据流
```
控制命令 → 任务解析 → 线程创建 → 资源分配 → 任务执行
```

**关键代码：**
```python
# TaskManager类
class TaskManager:
    def start_tasks(self, task_codes):    # 启动检测任务
    def stop_tasks(self, task_codes):     # 停止检测任务
    
# 队列结构
frame_queues = {
    'infrared': queue.Queue(maxsize=5),  # 红外图像队列
    'rgb': queue.Queue(maxsize=5)        # RGB图像队列
}
display_queue = queue.Queue(maxsize=10)  # 显示队列
```

### 2.3 模型推理数据流
```
图像帧 → 模型池 → 线程池 → NPU推理 → 结果返回
```

**关键代码：**
```python
# rknnpool_*.py系列
class rknnPoolExecutor_*:
    def put(self, frame):           # 提交推理任务
    def get(self):                  # 获取推理结果
    
# func_*.py系列
def myFunc_*(rknn_model, frame, num):
    # 图像预处理 → 模型推理 → 后处理 → 返回结果
```

## 3. 外部通信接口

### 3.1 UDP数据帧格式
```python
frame_format_meter = 'IIIIIIIff'  # 9个字段的二进制格式

# 字段定义：
# 字段1: 请求类型 (0=请求数据, 1=发送数据, 2=控制命令)
# 字段2: 设备类型 (0=服务器, 1=视觉系统, 2=机器人, 3=仪表)
# 字段3: 子设备类型
# 字段4: 子任务类型 (0=人脸, 1=仪表, 2=安全帽, 3=红外, 4=火焰, 5=温度, 6=气体, 7=吸烟)
# 字段5: 状态 (0=不存在, 1=存在, 3=完成)
# 字段6: 数据类型/具体信息
# 字段7: 保留字段
# 字段8: 数值数据 (float)
# 字段9: 数值数据 (float)
```

### 3.2 通信方向

#### 下行通信（服务器→视觉系统）
```
服务器 → UDP数据帧 → 视觉系统解析 → 任务控制
```

**控制命令示例：**
```python
# 启动任务命令
(2, 0, 0, task_code, 0, 1, 0, 0, 0)
# 停止任务命令
(2, 0, 0, task_code, 0, 2, 0, 0, 0)
# 关闭所有任务
(2, 0, 0, 0, 0, 0, 0, 0, 0)
```

#### 上行通信（视觉系统→服务器）
```
检测结果 → 数据封装 → UDP数据帧 → 服务器接收
```

**数据请求示例：**
```python
# 请求人脸数据
(0, 0, 1, 0, 0, 0, 0, 0, 0)
# 请求红外入侵数据
(0, 0, 1, 3, 0, 0, 0, 0, 0)
# 请求安全帽数据
(0, 0, 1, 2, 0, 0, 0, 0, 0)
# 请求火焰数据
(0, 0, 1, 4, 0, 0, 0, 0, 0)
# 请求吸烟数据
(0, 0, 1, 7, 0, 0, 0, 0, 0)
```

### 3.3 异常数据推送
```python
# 异常检测机制
abnormal_count = 0
abnormal_pushed = False

if class_result == 1:  # 检测到异常
    abnormal_count += 1
    if abnormal_count >= threshold and not abnormal_pushed:
        send_abnormal_data(task_code, state)
        abnormal_pushed = True
else:  # 正常状态
    abnormal_count = 0
    abnormal_pushed = False
```

**异常数据格式：**
```python
# 红外入侵异常
(1, 1, 0, 3, 1, 0, 0, 0, 0)
# 安全帽异常
(1, 1, 0, 2, 1, 1, 0, 0, 0)
# 吸烟异常
(1, 1, 0, 7, 1, 1, 0, 0, 0)
# 火焰异常
(1, 1, 0, 4, 1, 1, 0, 0, 0)
```

## 4. 各检测任务数据流

### 4.1 人脸识别
```
RGB图像 → RetinaFace检测 → 人脸对齐 → MobileFaceNet特征提取 → 特征匹配 → 身份识别
```

### 4.2 红外入侵检测
```
红外图像 → YOLOv7推理 → 人体检测 → 后处理 → 入侵判断
```

### 4.3 火焰检测
```
RGB图像 → YOLOv8推理 → 火焰检测 → 滑动窗口确认 → 火焰判断
```

### 4.4 安全帽检测
```
RGB图像 → YOLOv8推理 → 安全帽检测 → 滑动窗口确认 → 安全帽判断
```

### 4.5 吸烟检测
```
RGB图像 → YOLOv8推理 → 多类别检测 → 行为分析 → 吸烟判断
```

## 5. 状态管理

### 5.1 任务状态变量
```python
state_env = False        # 人脸识别任务状态
state_inf = False        # 红外入侵检测任务状态
state_flame = False      # 火焰检测任务状态
state_smoke = False      # 吸烟检测任务状态
state_hardhat = False    # 安全帽检测任务状态
```

### 5.2 状态管理流程
```
任务启动 → 状态设置(True) → 任务执行 → 任务结束 → 状态重置(False)
```

## 6. 性能优化

### 6.1 并发处理
```
多摄像头线程 → 多任务线程 → 多模型实例 → 多NPU核心
```

### 6.2 队列管理
```
图像队列(5帧) → 任务处理 → 显示队列(10帧) → 显示线程
```

### 6.3 资源复用
```
模型池 → 线程池 → NPU核心分配 → 内存管理
```

## 7. 通信协议特点

- **双向通信**: 支持命令下发和数据上报
- **实时性**: UDP协议保证低延迟
- **可靠性**: 异常检测和状态管理
- **扩展性**: 模块化设计便于扩展

## 8. 总结

整个系统通过精心设计的数据流和通信接口，实现了高效、可靠的视觉检测功能：

1. **摄像头自动识别**确保硬件兼容性
2. **多线程任务调度**提高系统并发性能
3. **RKNN模型池**优化NPU资源利用
4. **UDP双向通信**保证实时性和可靠性
5. **异常检测机制**避免误报和漏报

系统能够满足各种工业应用场景的需求，为智能视觉检测提供了完整的技术解决方案。
