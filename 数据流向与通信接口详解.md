# 视觉检测系统数据流向与通信接口详解

## 概述
本文档详细分析了视觉检测系统的完整数据流向，包括内部数据流、外部通信接口、协议格式和通信方式。系统采用多线程架构，通过UDP协议与外部系统进行双向通信。

## 1. 系统整体架构

### 1.1 核心组件
```
┌─────────────────┐    ┌─────────────────┐    ┌─────────────────┐
│   摄像头模块     │    │   任务管理模块   │    │   UDP通信模块   │
│                 │    │                 │    │                 │
│ • 红外摄像头     │───▶│ • 任务调度器     │───▶│ • UDP服务器     │
│ • RGB摄像头      │    │ • 线程池管理     │    │ • 数据帧处理     │
│ • 自动识别       │    │ • 队列管理       │    │ • 协议解析       │
└─────────────────┘    └─────────────────┘    └─────────────────┘
         │                       │                       │
         ▼                       ▼                       ▼
┌─────────────────┐    ┌─────────────────┐    ┌─────────────────┐
│   RKNN模型池    │    │   检测算法模块   │    │   外部系统      │
│                 │    │                 │    │                 │
│ • YOLOv7/YOLOv8 │    │ • 人脸识别       │    │ • 服务器        │
│ • RetinaFace    │    │ • 入侵检测       │    │ • 机器人        │
│ • MobileFaceNet │    │ • 火焰检测       │    │ • 仪表系统      │
└─────────────────┘    └─────────────────┘    └─────────────────┘
```

### 1.2 数据流向概览
```
摄像头采集 → 图像预处理 → 模型推理 → 后处理 → 结果分析 → UDP通信 → 外部系统
    ↑                                                              ↓
    └────────────────── 控制命令反馈 ──────────────────────────────┘
```

## 2. 内部数据流详解

### 2.1 摄像头数据流

#### 2.1.1 摄像头识别与初始化
```python
# video_number.py - 自动识别摄像头
def get_camera_numbers():
    # 扫描 /sys/class/video4linux/
    # 读取 modalias 识别硬件ID
    # 返回红外和RGB摄像头编号列表
```

**数据流：**
```
系统扫描 → 硬件识别 → 编号映射 → 摄像头列表
```

#### 2.1.2 摄像头管理
```python
# CameraManager类
class CameraManager:
    def get_infrared_camera(self):  # 获取红外摄像头
    def get_rgb_camera(self):       # 获取RGB摄像头
    def release_cameras(self):      # 释放摄像头资源
```

**数据流：**
```
摄像头请求 → 资源检查 → 设备打开 → 返回句柄
```

#### 2.1.3 图像采集
```python
# camera_capture函数
def camera_capture(cam, frame_queue, stop_event):
    while not stop_event.is_set():
        ret, frame = cam.read()     # 读取图像帧
        frame_queue.put(frame)      # 放入队列
```

**数据流：**
```
摄像头硬件 → OpenCV读取 → 图像帧 → 队列缓存 → 任务处理
```

### 2.2 任务调度数据流

#### 2.2.1 任务管理器
```python
# TaskManager类
class TaskManager:
    def start_tasks(self, task_codes):    # 启动检测任务
    def stop_tasks(self, task_codes):     # 停止检测任务
    def start_camera(self, cam_type):     # 启动摄像头
```

**数据流：**
```
控制命令 → 任务解析 → 线程创建 → 资源分配 → 任务执行
```

#### 2.2.2 队列管理
```python
# 队列结构
frame_queues = {
    'infrared': queue.Queue(maxsize=5),  # 红外图像队列
    'rgb': queue.Queue(maxsize=5)        # RGB图像队列
}
display_queue = queue.Queue(maxsize=10)  # 显示队列
```

**数据流：**
```
摄像头线程 → 图像队列 → 检测任务 → 结果队列 → 显示线程
```

### 2.3 模型推理数据流

#### 2.3.1 RKNN模型池
```python
# rknnpool_*.py系列
class rknnPoolExecutor_*:
    def put(self, frame):           # 提交推理任务
    def get(self):                  # 获取推理结果
    def release(self):              # 释放资源
```

**数据流：**
```
图像帧 → 模型池 → 线程池 → NPU推理 → 结果返回
```

#### 2.3.2 检测算法处理
```python
# func_*.py系列
def myFunc_*(rknn_model, frame, num):
    # 图像预处理
    # 模型推理
    # 后处理
    # 返回结果
```

**数据流：**
```
原始图像 → 预处理 → 模型输入 → 推理计算 → 后处理 → 检测结果
```

## 3. 外部通信接口

### 3.1 UDP通信协议

#### 3.1.1 数据帧格式
```python
frame_format_meter = 'IIIIIIIff'  # 9个字段的二进制格式

# 字段定义：
# 字段1: 请求类型 (REQUEST_DATA=0, GIVE_DATA=1, CONTROL_COMMOND=2)
# 字段2: 设备类型 (SERVER=0, VISION=1, ROBOT=2, METER=3)
# 字段3: 子设备类型
# 字段4: 子任务类型 (SUB_FACE=0, SUB_METER=1, SUB_HARDHAT=2, SUB_INF=3, SUB_FLAME=4, SUB_THR=5, SUB_GAS=6, SUB_SMOKE=7)
# 字段5: 状态 (EXIST=1, NOT_EXIST=0, FINSH=3)
# 字段6: 数据类型/具体信息
# 字段7: 保留字段
# 字段8: 数值数据 (float)
# 字段9: 数值数据 (float)
```

#### 3.1.2 通信方向

**下行通信（服务器→视觉系统）：**
```
服务器 → UDP数据帧 → 视觉系统解析 → 任务控制
```

**上行通信（视觉系统→服务器）：**
```
检测结果 → 数据封装 → UDP数据帧 → 服务器接收
```

### 3.2 控制命令接口

#### 3.2.1 任务控制命令
```python
# 启动任务命令
(2, 0, 0, task_code, 0, 1, 0, 0, 0)
# 停止任务命令
(2, 0, 0, task_code, 0, 2, 0, 0, 0)
# 关闭所有任务
(2, 0, 0, 0, 0, 0, 0, 0, 0)
```

**数据流：**
```
服务器命令 → UDP接收 → 命令解析 → 任务管理 → 任务执行/停止
```

#### 3.2.2 数据请求命令
```python
# 请求人脸数据
(0, 0, 1, 0, 0, 0, 0, 0, 0)
# 请求红外入侵数据
(0, 0, 1, 3, 0, 0, 0, 0, 0)
# 请求安全帽数据
(0, 0, 1, 2, 0, 0, 0, 0, 0)
# 请求火焰数据
(0, 0, 1, 4, 0, 0, 0, 0, 0)
# 请求吸烟数据
(0, 0, 1, 7, 0, 0, 0, 0, 0)
```

**数据流：**
```
服务器请求 → UDP接收 → 状态检查 → 数据准备 → UDP发送 → 服务器接收
```

### 3.3 异常数据推送

#### 3.3.1 异常检测机制
```python
# 连续异常帧计数
abnormal_count = 0
abnormal_pushed = False

# 异常确认逻辑
if class_result == 1:  # 检测到异常
    abnormal_count += 1
    if abnormal_count >= threshold and not abnormal_pushed:
        send_abnormal_data(task_code, state)
        abnormal_pushed = True
else:  # 正常状态
    abnormal_count = 0
    abnormal_pushed = False
```

**数据流：**
```
连续检测 → 异常计数 → 阈值判断 → 数据推送 → 服务器接收
```

#### 3.3.2 异常数据格式
```python
# 红外入侵异常
(1, 1, 0, 3, 1, 0, 0, 0, 0)
# 安全帽异常
(1, 1, 0, 2, 1, 1, 0, 0, 0)
# 吸烟异常
(1, 1, 0, 7, 1, 1, 0, 0, 0)
# 火焰异常
(1, 1, 0, 4, 1, 1, 0, 0, 0)
```

## 4. 各检测任务数据流

### 4.1 人脸识别数据流

#### 4.1.1 处理流程
```
RGB图像 → RetinaFace检测 → 人脸对齐 → MobileFaceNet特征提取 → 特征匹配 → 身份识别
```

#### 4.1.2 数据接口
```python
# 输入：RGB图像帧
# 输出：(processed_frame, name_list)
# 通信：name_ten列表存储最近识别的人名
```

### 4.2 红外入侵检测数据流

#### 4.2.1 处理流程
```
红外图像 → YOLOv7推理 → 人体检测 → 后处理 → 入侵判断
```

#### 4.2.2 数据接口
```python
# 输入：红外图像帧
# 输出：(processed_frame, class_inf)
# 通信：class_inf (0=无人, 1=有人)
```

### 4.3 火焰检测数据流

#### 4.3.1 处理流程
```
RGB图像 → YOLOv8推理 → 火焰检测 → 滑动窗口确认 → 火焰判断
```

#### 4.3.2 数据接口
```python
# 输入：RGB图像帧
# 输出：(processed_frame, class_flame)
# 通信：class_flame (0=无火焰, 1=有火焰)
```

### 4.4 安全帽检测数据流

#### 4.4.1 处理流程
```
RGB图像 → YOLOv8推理 → 安全帽检测 → 滑动窗口确认 → 安全帽判断
```

#### 4.4.2 数据接口
```python
# 输入：RGB图像帧
# 输出：(processed_frame, class_hardhat)
# 通信：class_hardhat (0=戴安全帽, 1=未戴安全帽)
```

### 4.5 吸烟检测数据流

#### 4.5.1 处理流程
```
RGB图像 → YOLOv8推理 → 多类别检测 → 行为分析 → 吸烟判断
```

#### 4.5.2 数据接口
```python
# 输入：RGB图像帧
# 输出：(processed_frame, class_smoke)
# 通信：class_smoke (0=未吸烟, 1=吸烟)
```

## 5. 状态管理数据流

### 5.1 任务状态变量
```python
# 全局状态变量
state_env = False        # 人脸识别任务状态
state_inf = False        # 红外入侵检测任务状态
state_flame = False      # 火焰检测任务状态
state_smoke = False      # 吸烟检测任务状态
state_hardhat = False    # 安全帽检测任务状态
```

### 5.2 状态管理流程
```
任务启动 → 状态设置(True) → 任务执行 → 任务结束 → 状态重置(False)
```

### 5.3 状态查询机制
```python
# UDP响应中的状态检查
if state_xxx is True:  # 任务运行中
    # 返回有效数据
else:  # 任务未运行
    # 返回默认数据
```

## 6. 性能优化数据流

### 6.1 并发处理
```
多摄像头线程 → 多任务线程 → 多模型实例 → 多NPU核心
```

### 6.2 队列管理
```
图像队列(5帧) → 任务处理 → 显示队列(10帧) → 显示线程
```

### 6.3 资源复用
```
模型池 → 线程池 → NPU核心分配 → 内存管理
```

## 7. 错误处理数据流

### 7.1 异常捕获
```python
try:
    # 正常处理流程
except Exception as e:
    print(f"错误信息: {e}")
    # 错误处理逻辑
```

### 7.2 资源清理
```python
def release(self):
    self.pool.shutdown()           # 关闭线程池
    for rknn_lite in self.rknnPool:
        rknn_lite.release()        # 释放模型资源
```

## 8. 通信协议总结

### 8.1 协议特点
- **双向通信**: 支持命令下发和数据上报
- **实时性**: UDP协议保证低延迟
- **可靠性**: 异常检测和状态管理
- **扩展性**: 模块化设计便于扩展

### 8.2 数据流向总结
```
外部系统 ←→ UDP协议 ←→ 视觉系统 ←→ 摄像头硬件
    ↑           ↑           ↑           ↑
  控制命令   数据帧格式   任务管理   图像采集
    ↓           ↓           ↓           ↓
  状态查询   协议解析   模型推理   图像处理
    ↓           ↓           ↓           ↓
  异常推送   数据封装   结果分析   显示输出
```

整个系统通过精心设计的数据流和通信接口，实现了高效、可靠的视觉检测功能，能够满足各种工业应用场景的需求。
