# 字典和管理器在智能视觉检测工程中的作用详解

## 1. 核心管理器类

### 1.1 CameraManager（摄像头管理器）

#### 作用概述
`CameraManager` 是摄像头资源的核心管理器，负责红外和RGB摄像头的获取、管理和释放。

#### 核心功能
```python
class CameraManager:
    def __init__(self):
        self.infrared_cam = None  # 红外摄像头实例
        self.rgb_cam = None      # RGB摄像头实例
        self.lock = threading.Lock()  # 线程锁，防止多线程同时访问摄像头
```

#### 主要方法
1. **`get_infrared_camera()`**：
   - 获取红外摄像头实例
   - 如果未初始化，则调用 `open_camera(video_number.inf_numbers)` 创建
   - 使用线程锁确保线程安全

2. **`get_rgb_camera()`**：
   - 获取RGB摄像头实例
   - 如果未初始化，则调用 `open_camera(video_number.rgb_numbers)` 创建
   - 使用线程锁确保线程安全

3. **`release_cameras()`**：
   - 释放所有摄像头资源
   - 防止内存泄漏和资源占用

4. **`release_inf()`**：
   - 专门释放红外摄像头资源
   - 用于红外任务停止时的资源清理

#### 设计优势
- **单例模式**：确保每个摄像头类型只有一个实例
- **线程安全**：使用锁机制防止并发访问冲突
- **资源管理**：自动管理摄像头的生命周期
- **错误处理**：优雅处理摄像头打开失败的情况

### 1.2 TaskManager（任务管理器）

#### 作用概述
`TaskManager` 是整个系统的核心调度器，负责管理所有检测任务的启动、停止和资源分配。

#### 核心字典结构
```python
class TaskManager:
    def __init__(self):
        self.cam_manager = CameraManager()  # 摄像头管理器实例
        self.threads = {}                   # 存储任务线程的字典
        self.stop_events = {}               # 存储停止事件的字典
        self.frame_queues = {               # 帧队列字典
            'infrared': queue.Queue(maxsize=5),  # 红外摄像头队列，最大5帧
            'rgb': queue.Queue(maxsize=5)        # RGB摄像头队列，最大5帧
        }
        self.camera_threads = {}            # 存储摄像头线程的字典
        self.display_queue = queue.Queue(maxsize=10)  # 共享显示队列，最大10帧
```

## 2. 核心字典详解

### 2.1 `self.threads` - 任务线程字典

#### 作用
存储所有正在运行的检测任务线程实例。

#### 结构
```python
self.threads = {
    0: <Thread object>,  # 人脸识别任务线程
    2: <Thread object>,  # 安全帽检测任务线程
    3: <Thread object>,  # 红外入侵检测任务线程
    4: <Thread object>,  # 火焰检测任务线程
    5: <Thread object>   # 吸烟检测任务线程
}
```

#### 功能
- **任务跟踪**：记录哪些任务正在运行
- **线程管理**：提供线程实例用于停止和等待
- **状态查询**：可以检查特定任务是否在运行

#### 使用场景
```python
# 检查任务是否运行
if task_code in self.threads:
    print(f"任务 {TASK_CODES[task_code]} 正在运行")

# 停止特定任务
if task_code in self.threads:
    self.stop_events[task_code].set()  # 设置停止标志
    self.threads[task_code].join()     # 等待线程结束
    del self.threads[task_code]        # 从字典中删除
```

### 2.2 `self.stop_events` - 停止事件字典

#### 作用
存储每个任务的停止事件，用于优雅地停止任务线程。

#### 结构
```python
self.stop_events = {
    0: <Event object>,  # 人脸识别任务停止事件
    2: <Event object>,  # 安全帽检测任务停止事件
    3: <Event object>,  # 红外入侵检测任务停止事件
    4: <Event object>,  # 火焰检测任务停止事件
    5: <Event object>   # 吸烟检测任务停止事件
}
```

#### 功能
- **优雅停止**：通过设置事件标志来通知线程停止
- **线程同步**：确保线程能够及时响应停止命令
- **资源清理**：在停止时正确释放资源

#### 工作机制
```python
# 在任务线程中检查停止事件
while not stop_event.is_set():
    # 处理帧数据
    frame = frame_queue.get(timeout=1)
    # ... 处理逻辑 ...

# 在主线程中停止任务
self.stop_events[task_code].set()  # 设置停止标志
self.threads[task_code].join()     # 等待线程结束
```

### 2.3 `self.frame_queues` - 帧队列字典

#### 作用
管理不同类型摄像头的帧数据队列，实现生产者-消费者模式。

#### 结构
```python
self.frame_queues = {
    'infrared': queue.Queue(maxsize=5),  # 红外摄像头队列，最大5帧
    'rgb': queue.Queue(maxsize=5)        # RGB摄像头队列，最大5帧
}
```

#### 功能
- **数据缓冲**：缓存摄像头捕获的帧数据
- **线程通信**：连接摄像头线程和检测任务线程
- **流量控制**：通过队列大小限制内存使用
- **数据隔离**：红外和RGB数据分别存储

#### 工作流程
```python
# 摄像头线程（生产者）
def camera_capture(cam, frame_queue, stop_event):
    while not stop_event.is_set():
        ret, frame = cam.read()
        if frame_queue.full():
            frame_queue.get()  # 丢弃最老的帧
        frame_queue.put(frame)

# 检测任务线程（消费者）
def detection_task(frame_queue, display_queue, stop_event):
    while not stop_event.is_set():
        frame = frame_queue.get(timeout=1)
        # 处理帧数据
        # 将结果放入显示队列
```

### 2.4 `self.camera_threads` - 摄像头线程字典

#### 作用
管理摄像头捕获线程，确保每个摄像头类型只有一个捕获线程。

#### 结构
```python
self.camera_threads = {
    'infrared': <Thread object>,  # 红外摄像头捕获线程
    'rgb': <Thread object>        # RGB摄像头捕获线程
}
```

#### 功能
- **线程复用**：多个任务可以共享同一个摄像头线程
- **资源优化**：避免为每个任务创建独立的摄像头线程
- **状态管理**：跟踪摄像头线程的运行状态

#### 使用场景
```python
# 启动摄像头线程
if cam_type not in self.camera_threads:
    stop_event = threading.Event()
    self.camera_threads[cam_type] = threading.Thread(
        target=camera_capture,
        args=(cam, self.frame_queues[cam_type], stop_event)
    )
    self.camera_threads[cam_type].start()
    self.stop_events[cam_type] = stop_event
```

### 2.5 `self.display_queue` - 显示队列

#### 作用
共享的显示队列，用于所有检测任务向显示线程发送处理结果。

#### 结构
```python
self.display_queue = queue.Queue(maxsize=10)  # 共享显示队列，最大10帧
```

#### 功能
- **结果展示**：统一管理所有检测任务的显示结果
- **线程通信**：连接检测任务线程和显示线程
- **数据格式**：存储 (processed_frame, task_code) 元组

#### 工作流程
```python
# 检测任务线程发送结果
display_queue.put((processed_frame, task_code))

# 显示线程接收并显示
def show_frames(display_queue):
    while True:
        frame, task_code = display_queue.get(timeout=1)
        cv2.imshow(f"Task {task_code}", frame)
```

## 3. 系统架构优势

### 3.1 模块化设计
- **职责分离**：每个管理器负责特定的功能领域
- **松耦合**：组件之间通过接口通信，降低依赖
- **可扩展**：易于添加新的检测任务和摄像头类型

### 3.2 资源管理
- **内存控制**：通过队列大小限制内存使用
- **资源复用**：多个任务共享摄像头资源
- **自动清理**：任务停止时自动释放资源

### 3.3 线程安全
- **锁机制**：使用线程锁保护共享资源
- **事件驱动**：使用事件机制进行线程间通信
- **优雅停止**：通过事件标志实现线程的优雅停止

### 3.4 性能优化
- **队列缓冲**：减少线程阻塞，提高处理效率
- **资源复用**：避免重复创建和销毁资源
- **流量控制**：防止内存溢出和系统过载

## 4. 实际应用场景

### 4.1 多任务并发
```python
# 同时运行多个检测任务
task_manager.start_tasks([0, 2, 3])  # 人脸识别、安全帽检测、红外入侵检测
```

### 4.2 动态任务管理
```python
# 动态启动和停止任务
task_manager.start_tasks([4])  # 启动火焰检测
task_manager.stop_tasks([2])   # 停止安全帽检测
```

### 4.3 资源监控
```python
# 检查系统状态
print(f"运行中的任务: {list(task_manager.threads.keys())}")
print(f"摄像头线程: {list(task_manager.camera_threads.keys())}")
```

## 5. 总结

这些字典和管理器构成了一个完整的智能视觉检测系统的核心架构：

1. **CameraManager**：确保摄像头资源的正确管理和线程安全访问
2. **TaskManager**：提供统一的任务调度和资源管理接口
3. **各种字典**：实现高效的数据存储、线程管理和通信机制

这种设计使得系统能够：
- 支持多种检测任务的并发运行
- 高效管理有限的硬件资源
- 提供稳定的线程间通信
- 实现优雅的任务启动和停止
- 便于系统的扩展和维护
